#include "StdAfx.h"
#include "windows.h"
#include "ProtocolCommBackgroundThread.h"
#include <iostream>
#include <iomanip>

ProtocolCommBackgroundThread::ProtocolCommBackgroundThread(void) : thread(0)
{
	// register all callbacks/handlers to supported protocol services
	callbackMap.insert(std::pair<uint8_t, IService *>(KISS_VERSION_AND_ID, &srvVersionAndId));

	// initialize and open serial port
	const BOOL serialInitResult = s.init();

	// create a new instance of serial RX background thread
	serialThread = new SRBT(&s, &callbackMap);

	// set serial context for all services handlers
	srvVersionAndId.setSerialContext(&s);

	// create mutex which will protect agains starting two paralell comm transactions
	threadMutex = CreateMutex(NULL, FALSE, L"ProtocolCommMutex");

	// create an event which will be generated by callback in each service handler
	serviceSyncEvent = CreateEvent(NULL, FALSE, FALSE, L"ServiceSyncEv");

	std::cout << "I = PCBT::ProtocolCommBackgroundThread" << std::endl;
	std::cout << "D = PCBT::ProtocolCommBackgroundThread, threadMutex: 0x" << std::hex 
		<< threadMutex << std::dec << std::endl;
	std::cout << "D = PCBT::ProtocolCommBackgroundThread, serviceSyncEvent: 0x" << std::hex 
		<< serviceSyncEvent << std::dec << std::endl;

}

ProtocolCommBackgroundThread::~ProtocolCommBackgroundThread(void)
{
}

BOOL ProtocolCommBackgroundThread::commVersionAndUpdateGui(HWND mainWindow, HWND editCodeplugWindow)
{
	BOOL result = false;

	DWORD threadId = 0;

	memset(&this->srvVersionAndId_context, 0x00, sizeof(CTXPCBTVER));

	this->srvVersionAndId_context.editCodeplugWindow = editCodeplugWindow;
	this->srvVersionAndId_context.mainWindow = mainWindow;
	this->srvVersionAndId_context.getVersionAndId = &this->srvVersionAndId;
	this->srvVersionAndId_context.mutex = this->threadMutex;

	thread = CreateThread(
				NULL, 
				NULL, 
				ProtocolCommBackgroundThread_GetVersion, 
				&this->srvVersionAndId_context, 
				NULL,
				&threadId);

	if (thread != NULL)
	{
		result = true;
	}

	return result;
}

BOOL ProtocolCommBackgroundThread::getVersion(LPCSV p) 
{
	BOOL result = false;

	if (p != NULL)
	{
		p->kissVersion = this->srvVersionAndId_context.srvVersionAndIdResult.kissVersion;
		memcpy(
			p->softwareVersion, 
			this->srvVersionAndId_context.srvVersionAndIdResult.softwareVersion,
			sizeof(CHAR) * 5);

		p->type = this->srvVersionAndId_context.srvVersionAndIdResult.type;
	}

	return result;
}
